name: Personal Execution Stations CI/CD

on:
  push:
    branches: [ main, develop ]
    paths: 
      - 'execution-stations/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'execution-stations/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      action:
        description: 'Action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
        - plan
        - apply
        - validate
        - destroy

env:
  TERRAFORM_VERSION: '1.5.0'
  KUBECTL_VERSION: '1.28.0'
  HELM_VERSION: '3.12.0'

jobs:
  # Validation and Testing
  validate:
    name: Validate Configuration
    runs-on: ubuntu-latest
    outputs:
      changed-files: ${{ steps.changes.outputs.execution-stations }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Check for changes
      uses: dorny/paths-filter@v2
      id: changes
      with:
        filters: |
          execution-stations:
            - 'execution-stations/**'

    - name: Set up Python
      if: steps.changes.outputs.execution-stations == 'true'
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install Python dependencies
      if: steps.changes.outputs.execution-stations == 'true'
      working-directory: execution-stations
      run: |
        pip install PyYAML jsonschema
        chmod +x scripts/*.py

    - name: Validate Python scripts
      if: steps.changes.outputs.execution-stations == 'true'
      working-directory: execution-stations
      run: |
        python3 -m py_compile scripts/generate-profile.py
        python3 scripts/generate-profile.py --list-styles

    - name: Setup Terraform
      if: steps.changes.outputs.execution-stations == 'true'
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}

    - name: Terraform Format Check
      if: steps.changes.outputs.execution-stations == 'true'
      working-directory: execution-stations/terraform
      run: terraform fmt -check -recursive

    - name: Terraform Validate
      if: steps.changes.outputs.execution-stations == 'true'
      working-directory: execution-stations/terraform
      run: |
        terraform init -backend=false
        terraform validate

    - name: Validate Kubernetes manifests
      if: steps.changes.outputs.execution-stations == 'true'
      run: |
        # Install kubeval for manifest validation
        wget https://github.com/instrumenta/kubeval/releases/latest/download/kubeval-linux-amd64.tar.gz
        tar xf kubeval-linux-amd64.tar.gz
        sudo cp kubeval /usr/local/bin
        
        # Validate Kubernetes YAML files
        find execution-stations/kubernetes -name "*.yaml" -exec kubeval {} \;

    - name: Validate shell scripts
      if: steps.changes.outputs.execution-stations == 'true'
      run: |
        sudo apt-get update && sudo apt-get install -y shellcheck
        find execution-stations -name "*.sh" -exec shellcheck {} \;

  # Security Scanning
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: validate
    if: needs.validate.outputs.changed-files == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: 'execution-stations'
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

    - name: Run Checkov static analysis
      uses: bridgecrewio/checkov-action@master
      with:
        directory: execution-stations/terraform
        framework: terraform
        output_format: sarif
        output_file_path: checkov-results.sarif

  # Development Environment Deployment
  deploy-dev:
    name: Deploy to Development
    runs-on: ubuntu-latest
    needs: [validate, security-scan]
    if: |
      github.ref == 'refs/heads/develop' && 
      needs.validate.outputs.changed-files == 'true'
    environment: development
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBECTL_VERSION }}

    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: ${{ env.HELM_VERSION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}

    - name: Configure AWS credentials
      if: ${{ vars.CLOUD_PROVIDER == 'aws' }}
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION }}

    - name: Configure kubeconfig
      run: |
        echo "${{ secrets.KUBECONFIG_DEV }}" | base64 -d > ~/.kube/config
        chmod 600 ~/.kube/config

    - name: Bootstrap cluster (if needed)
      working-directory: execution-stations
      run: |
        chmod +x scripts/bootstrap-cluster.sh
        make bootstrap ENV=dev

    - name: Terraform Plan
      working-directory: execution-stations/terraform
      run: |
        terraform init
        terraform plan -var environment=dev -out=tfplan-dev

    - name: Terraform Apply
      working-directory: execution-stations/terraform
      run: terraform apply -auto-approve tfplan-dev

    - name: Validate Deployment
      working-directory: execution-stations
      run: |
        chmod +x scripts/validate-deployment.sh
        make validate ENV=dev

    - name: Deploy Test Profile
      working-directory: execution-stations
      run: |
        make generate-profile USER_ID=ci-test COGNITIVE_STYLE=experimental_creative
        make deploy-profile USER_ID=ci-test ENV=dev

    - name: Integration Tests
      working-directory: execution-stations
      run: |
        # Wait for station to be ready
        kubectl wait --for=condition=available --timeout=300s \
          deployment/execution-station-ci-test -n execution-stations-dev
        
        # Basic connectivity test
        kubectl port-forward -n execution-stations-dev \
          service/execution-station-ci-test 8080:80 &
        sleep 10
        curl -f http://localhost:8080/health || exit 1

    - name: Cleanup Test Resources
      if: always()
      run: |
        kubectl delete deployment execution-station-ci-test -n execution-stations-dev --ignore-not-found
        kubectl delete service execution-station-ci-test -n execution-stations-dev --ignore-not-found
        kubectl delete ingress execution-station-ci-test -n execution-stations-dev --ignore-not-found
        kubectl delete pvc workspace-ci-test -n execution-stations-dev --ignore-not-found

  # Staging Environment Deployment  
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [validate, security-scan, deploy-dev]
    if: github.ref == 'refs/heads/main'
    environment: staging
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup tools
      run: |
        # Setup kubectl, helm, terraform (same as dev job)
        curl -LO "https://dl.k8s.io/release/v${{ env.KUBECTL_VERSION }}/bin/linux/amd64/kubectl"
        sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
        
        curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
        chmod 700 get_helm.sh && ./get_helm.sh --version v${{ env.HELM_VERSION }}
        
        wget https://releases.hashicorp.com/terraform/${{ env.TERRAFORM_VERSION }}/terraform_${{ env.TERRAFORM_VERSION }}_linux_amd64.zip
        unzip terraform_${{ env.TERRAFORM_VERSION }}_linux_amd64.zip
        sudo mv terraform /usr/local/bin/

    - name: Configure kubeconfig
      run: |
        echo "${{ secrets.KUBECONFIG_STAGING }}" | base64 -d > ~/.kube/config
        chmod 600 ~/.kube/config

    - name: Deploy to Staging
      working-directory: execution-stations
      run: |
        make bootstrap ENV=staging
        make apply ENV=staging
        make validate ENV=staging

    - name: Notify Slack
      if: always()
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: '#execution-stations'
        webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Production Deployment (Manual Approval Required)
  deploy-prod:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [validate, security-scan, deploy-staging]
    if: |
      github.ref == 'refs/heads/main' && 
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'prod')
    environment: production
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Require Approval
      uses: hmarr/auto-approve-action@v3
      if: contains(github.event.inputs.action, 'apply')
      with:
        github-token: "${{ secrets.GITHUB_TOKEN }}"
        review-message: "Auto-approving production deployment"

    - name: Setup tools
      run: |
        curl -LO "https://dl.k8s.io/release/v${{ env.KUBECTL_VERSION }}/bin/linux/amd64/kubectl"
        sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
        
        curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
        chmod 700 get_helm.sh && ./get_helm.sh --version v${{ env.HELM_VERSION }}
        
        wget https://releases.hashicorp.com/terraform/${{ env.TERRAFORM_VERSION }}/terraform_${{ env.TERRAFORM_VERSION }}_linux_amd64.zip
        unzip terraform_${{ env.TERRAFORM_VERSION }}_linux_amd64.zip
        sudo mv terraform /usr/local/bin/

    - name: Configure kubeconfig
      run: |
        echo "${{ secrets.KUBECONFIG_PROD }}" | base64 -d > ~/.kube/config
        chmod 600 ~/.kube/config

    - name: Production Deployment
      working-directory: execution-stations
      run: |
        case "${{ github.event.inputs.action }}" in
          "plan")
            make init ENV=prod
            make plan ENV=prod
            ;;
          "apply")
            make bootstrap ENV=prod
            make apply ENV=prod
            make validate ENV=prod
            ;;
          "validate")
            make validate ENV=prod
            ;;
          "destroy")
            echo "Destroy action requires manual confirmation"
            make destroy ENV=prod
            ;;
        esac

    - name: Notify Teams
      if: always()
      run: |
        # Send notifications to multiple channels
        curl -X POST -H 'Content-type: application/json' \
          --data '{"text":"ðŸš€ Production deployment ${{ job.status }}: Execution Stations"}' \
          "${{ secrets.SLACK_WEBHOOK_URL }}"

  # Documentation Update
  update-docs:
    name: Update Documentation  
    runs-on: ubuntu-latest
    needs: validate
    if: |
      github.ref == 'refs/heads/main' && 
      needs.validate.outputs.changed-files == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Generate Documentation
      working-directory: execution-stations
      run: |
        chmod +x scripts/generate-profile.py
        make docs

    - name: Deploy to GitHub Pages
      if: github.ref == 'refs/heads/main'
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: execution-stations/docs
        cname: execution-stations-docs.example.com